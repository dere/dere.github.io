<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>/dev/zero</title>
    <description>Derek Maciel's site and blog</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>What would happen if two chess AIs faced each other?</title>
        <description>&lt;p&gt;If two chess AIs faced each other, what would happen? What if they always played the most optimal move and never made a mistake?&lt;/p&gt;

&lt;p&gt;As of today, according to the &lt;a href=&quot;http://www.chessgames.com/chessstats.html&quot;&gt;ChessGames.com database&lt;/a&gt; of over 800,000 games, White wins 37.67% of games compared to 27.92% for Black. 34% of games end in a draw. In other words, White’s &lt;a href=&quot;https://en.wikipedia.org/wiki/Glossary_of_chess#Winning_percentage&quot;&gt;winning percentage&lt;/a&gt; is 54.67% compared to Black’s 44.92%. These odds are comparable for both human players and computer players. It would appear that due to this slight advantage, a game between two perfect AI players would result in White winning more often than Black. However, another thing to consider are drawn games.&lt;/p&gt;

&lt;p&gt;As noted above, games in general end in a draw about 34% of the time, but this rate skyrockets the more skilled the players. According to &lt;a href=&quot;http://en.chessbase.com/post/sonas-what-exactly-is-the-problem-&quot;&gt;Chess News&lt;/a&gt;, chess games end in a draw around 20% of the time when the highest FIDE rating between the two players is 1500 and increases to nearly 60% for a FIDE rating of 2800, which represents the highest rated players in the world. When considering all World Chess Championships since 2008, games have resulted in a draw 69.7% of the time over 76 games. There are a few theories for this, but the main theory is that White’s advantage is not enough to alone allow White to gain a winning position, and since Black is also a very skilled opponent who makes few mistakes, the position remains neutral for both players until they agree to a draw.&lt;/p&gt;

&lt;p&gt;However, I don’t believe this will apply to a perfect computer AI because of how well they can calculate future moves. In many cases, even the best players are unable to tell that a position allows a player to force a win rather than a draw because they require calculating hundreds of moves in the future, compared to the average of around 50 moves per game. &lt;a href=&quot;https://medium.com/conversations-with-tyler/garry-kasparov-tyler-cowen-chess-iq-ai-putin-3bf28baf4dba&quot;&gt;In an interview&lt;/a&gt;, Garry Kasparov, which many consider to be the greatest player of all time, commented on a game like this:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;It said mate in 490 moves, first mate. Now, I can tell you that — even being a very decent player — for the first 400 moves, I could hardly understand why these pieces moved around like a dance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The problem being faced is that the sheer number of possible positions in chess may be impossible to calculate. In 2007, Jonathan Schaeffer and his colleagues at the University of Alberta published a proof that solved checkers. After 16 years of computation on as many as 200 consumer desktop computers, all possible endgames involving fewer than 10 pieces were evaluated into a database of 39 trillion positions. For chess however, it is currently estimated that there are more unique chess positions than there are atoms in the observable universe, making it impossible to calculate with today’s technology. Only endgames with no more than 7 pieces (including the two kings) have been solved, and it is not expected than 8 pieces will be solved any time soon, let alone all 32 pieces.&lt;/p&gt;

&lt;p&gt;So to answer the question asked in the title, an AI that can perfectly play can not exist with current technology because it cannot calculate the sheer number of possibilities in chess. However, the best AI today perform similarly to the best players in the world, forcing a draw on their opponent if a winning solution cannot be found.&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Jun 2017 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/2017/06/10/two-perfect-chess-players/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/06/10/two-perfect-chess-players/</guid>
      </item>
    
      <item>
        <title>An Introduction to the Cache Coherence Problem</title>
        <description>&lt;p&gt;As I was finishing up the spring semester in school, I have also been asking around to find a professor who would be interested in either sponsoring an Independent Study or working with me on research on systems programming or operating systems. I have found one professor who is interested in doing research with me on his current project on TLB coherence&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; and cache coherence. I have been reading papers and a textbook on the topic and I find it pretty interesting, so that is what this blog post will be on.&lt;/p&gt;

&lt;h2 id=&quot;what-is-cache-coherence&quot;&gt;What is cache coherence?&lt;/h2&gt;

&lt;p&gt;In many modern architectures, multiple CPU cores will have their own caches of system memory. A big problem these architectures face is maintaining coherence between these caches, meaning all of the cores are on the same page on what value at a certain address is the most up-to-date value. This is a complicated issue because each core may update a value in their cache at any time, but may not immediately update the value in main memory or may not immediately notify other cores to update their own caches.&lt;/p&gt;

&lt;p&gt;In the example below, cores 1 and 2 read a value &lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt; from main memory, then later core 1 updates this value in its own cache and in main memory to &lt;code class=&quot;highlighter-rouge&quot;&gt;10&lt;/code&gt;. Detecting that the value in Core 2’s cache is incorrect is the crux of this problem.&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; This is even harder when the number of CPUs or cores increases. (Note that this example is deliberately simple. It ignores the fact that a core usually has multiple levels of cache, and that blocks of data are cached together and not individual values.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-05-31-intro-cache-coherence/incoherent.png&quot; alt=&quot;Cache incoherence example&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cache-coherence-protocols&quot;&gt;Cache coherence protocols&lt;/h2&gt;

&lt;p&gt;Coherency is maintained by following a coherence protocol. A cache controller, which sits between a core and its cache and main memory, communicates with other cache controllers according to its coherence protocol. The main memory controller is the same except it does not interact with any core of its own. Here is an example of a two-core system:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-05-31-intro-cache-coherence/cache-controllers.png&quot; alt=&quot;Cache controller diagram&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-swmr-invariant&quot;&gt;The SWMR invariant&lt;/h2&gt;

&lt;p&gt;Coherence protocols are based on some invariant such that if the invariant holds then the system is coherent, and incoherent otherwise. The simplest invariant is the Single Writer, Multiple Readers (SWMR) invariant, which states that there are two valid possiblities: either a single controller has both read and write privileges on a block in its cache but no other controller has either read or write privileges, or multiple controllers have read privileges but none can write.&lt;/p&gt;

&lt;p&gt;It is easy to see that if this invariant holds then cache incoherency is impossible. Imagine the example above where core 1 updates a value in its cache. If two controllers had read privileges to the same block, then neither would have write privileges. In order for core 1’s cache controller to update the value in its own cache, it would first have to request to become the Single Writer for that block. By definition, that would mean core 2’s cache controller would no longer have permission to read that block from its cache; it is invalidated. When core 2 attempts to read that block in the future, its cache controller would see the invalidation and a cache miss would occur; the read would be fulfilled from system memory. If core 2’s cache controller wishes to cache that block, it would have to request core 1’s cache controller to go back to the Multiple Readers state.&lt;/p&gt;

&lt;h2 id=&quot;types-of-protocols&quot;&gt;Types of protocols&lt;/h2&gt;

&lt;p&gt;There are many protocol variants but there are two main classes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Snooping protocols: At any given point, for a particular block, one controller (cache or memory controller) has the most up-to-date value for the block and considers itself to be the “owner” of the block. Any cache controllers wishing to read that block issues a broadcast to all other cache controllers for the most up-to-date value; the owner of the block responds and the others ignore the request. These protocols rely on the network to maintain message order.&lt;/li&gt;
  &lt;li&gt;Directory protocols: The main memory controller is designated the “home” controller, and all cache controllers wishing to read a block first issue a request directly to the home. The home maintains a directory of the owners of each block, and if the home is not the owner, the home unicasts a request to the owner, which responds directly to the original requestor.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Another major design decision independent of whether the protocol is snooping or directory is what to do when a cache writes to a block:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Invalidate protocol: the cache broadcasts for all other caches to invalidate the block&lt;/li&gt;
  &lt;li&gt;Update protocol: the core broadcasts the new value to all other caches to update their values for the block. These are rare however due to the bandwidth necessary to broadcast an entire cache block.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;additional-reading&quot;&gt;Additional reading&lt;/h2&gt;

&lt;p&gt;I would have liked to go into more depth about the design of cache coherence protocols, but the information necessary would not fit well in a blog article. To learn more, I recommend A Primer On Memory Consistency and Cache Coherence.&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;As in &lt;a href=&quot;https://users.cs.duke.edu/~alvy/papers/hpca10_unitd.pdf&quot;&gt;this paper&lt;/a&gt;, I will be referring to the maintenance of coherence between the TLB and page tables as “TLB coherence” because it is very similar to cache coherence, and not “TLB consistency” as is usually used.&amp;nbsp;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;This example image could also show a different scenario in which cores 1 and 2 read the value &lt;code class=&quot;highlighter-rouge&quot;&gt;10&lt;/code&gt; from main memory, and later core 2 updates this value to &lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt; but has not yet updated main memory. Now the issue is that both main memory and core 1’s cache need to detect that its values are incorrect.&amp;nbsp;&lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 31 May 2017 00:00:00 -0400</pubDate>
        <link>http://localhost:4000/2017/05/31/intro-cache-coherence/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/05/31/intro-cache-coherence/</guid>
      </item>
    
      <item>
        <title>A Beginner's Guide to x86 Assembly, Part 2 of 2</title>
        <description>&lt;p&gt;In the &lt;a href=&quot;/2017-02-12/beginners-assembly-part1/&quot;&gt;previous part of this series&lt;/a&gt; the main topics of x86 assembly programming such as the call stack x86 calling convention were introduced. In this final part we will apply that knowledge to write our RPN calculator.&lt;/p&gt;

&lt;p&gt;The complete code of our calculator can be found &lt;a href=&quot;https://gist.github.com/dere/9dff75a67710207e16cd6a8531393ccf&quot;&gt;here&lt;/a&gt;. It is heavily commented and may serve as a sufficient learning resource for those of you with some knowledge of assembly already. Now, lets get started.&lt;/p&gt;

&lt;p&gt;For those of you unfamiliar with Reverse Polish notation (sometimes called postfix notation), expressions are evaluated using a stack. Therefore, we’ll need to create a stack to use as well as some &lt;code class=&quot;highlighter-rouge&quot;&gt;_pop&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;_push&lt;/code&gt; functions to manipulate that stack. We’ll also need a function called &lt;code class=&quot;highlighter-rouge&quot;&gt;_print_answer&lt;/code&gt; which will print the string-representation of the numeric result at the end of our calculation.&lt;/p&gt;

&lt;h2 id=&quot;creating-the-stack&quot;&gt;Creating the stack&lt;/h2&gt;

&lt;p&gt;First we’ll define a space in memory we will use for our stack as well as our global &lt;code class=&quot;highlighter-rouge&quot;&gt;stack_size&lt;/code&gt; variable. We will wish to modify these variables so they will not go in the &lt;code class=&quot;highlighter-rouge&quot;&gt;.rodata&lt;/code&gt; section, but instead, &lt;code class=&quot;highlighter-rouge&quot;&gt;.data&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stack_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;dd&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;; create a dword (4-byte) variable set to zero&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;dd&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;; fill the stack with 256 dword zeroes &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then we can implement the functions &lt;code class=&quot;highlighter-rouge&quot;&gt;_push&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;_pop&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_push&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;enter&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; Save the callee-saved registers that I'll be using&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack_size&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;; Insert the arg into the stack. We scale&lt;/span&gt;
                                &lt;span class=&quot;c&quot;&gt;; by 4 because each dword is 4 bytes each&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;inc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dword&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack_size&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;; Add 1 to stack_size&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; Restore the callee-saved registers we used&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;leave&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ret&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_pop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;enter&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; Save the callee-saved registers&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;dec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dword&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack_size&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;; Subtract 1 from stack_size first&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack_size&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;; Set the number at the top of the stack to eax&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; Here I'd restore the callee-saved registers, but I didn't save any&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;leave&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;printing-numbers&quot;&gt;Printing numbers&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_print_answer&lt;/code&gt; is a lot more complicated because we will have to convert numbers to strings, and that process requires using a few other functions. We’ll need a &lt;code class=&quot;highlighter-rouge&quot;&gt;_putc&lt;/code&gt; function which will print a single character, a &lt;code class=&quot;highlighter-rouge&quot;&gt;mod&lt;/code&gt; function to calculate the modulus of two arguments, and &lt;code class=&quot;highlighter-rouge&quot;&gt;_pow_10&lt;/code&gt; to calculate a power of 10. You’ll see why we need them later. These are pretty simple so lets do that now:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_pow_10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;enter&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;; set ecx (caller-saved) to function arg&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;; first power of 10 (10**0 = 1)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_pow_10_loop_start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;; multiply eax by 10 until ecx is 0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;je&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_pow_10_loop_end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;imul&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_pow_10_loop_start&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_pow_10_loop_end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;leave&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ret&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_mod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;enter&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;; explained below&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;idiv&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;; divides the 64-bit integer [edx:eax] by ebx. We only want to&lt;/span&gt;
                        &lt;span class=&quot;c&quot;&gt;; divide the 32-bit integer eax, so we set edx to zero. The&lt;/span&gt;
                        &lt;span class=&quot;c&quot;&gt;; result of this division is stored in eax, and the remainder&lt;/span&gt;
                        &lt;span class=&quot;c&quot;&gt;; is stored in edx. As always, you can find more about this&lt;/span&gt;
                        &lt;span class=&quot;c&quot;&gt;; instruction in the resources below.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;; return the modulus&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;leave&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ret&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_putc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;enter&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x04&lt;/span&gt;       &lt;span class=&quot;c&quot;&gt;; write()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;; standard out&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;lea&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;; the input character&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;; print only 1 character&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x80&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;leave&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now, how do we print the digits of a number? First, note that we can get the last digit of a number by finding the modulus of &lt;code class=&quot;highlighter-rouge&quot;&gt;10&lt;/code&gt; (for example, &lt;code class=&quot;highlighter-rouge&quot;&gt;123 % 10 = 3&lt;/code&gt;), and we can get the next digit by finding the modulus of &lt;code class=&quot;highlighter-rouge&quot;&gt;100&lt;/code&gt; and dividing that result by &lt;code class=&quot;highlighter-rouge&quot;&gt;10&lt;/code&gt; (for example, &lt;code class=&quot;highlighter-rouge&quot;&gt;(123 % 100)/10 = 2&lt;/code&gt;). In general, we can find a specific digit (going from right to left) of a number by finding &lt;code class=&quot;highlighter-rouge&quot;&gt;(number % 10**n) / 10**(n-1)&lt;/code&gt;, where the ones digit would be &lt;code class=&quot;highlighter-rouge&quot;&gt;n = 1&lt;/code&gt;, the tens digit &lt;code class=&quot;highlighter-rouge&quot;&gt;n = 2&lt;/code&gt; and so on.&lt;/p&gt;

&lt;p&gt;Using that knowledge we can find all the digits of a number by starting at &lt;code class=&quot;highlighter-rouge&quot;&gt;n = 1&lt;/code&gt; and iterating to &lt;code class=&quot;highlighter-rouge&quot;&gt;n = 10&lt;/code&gt; (the most digits a signed 4-byte integer can have). However, it would be a lot easier if we could go from left to right – that would allow us to print each character as we find it and prevent trailing zeroes to the left of the number – so we’ll instead iterate from &lt;code class=&quot;highlighter-rouge&quot;&gt;n = 10&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;n = 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It should look something like the following C code:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define MAX_DIGITS 10
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_answer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// if the number is negative
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;putc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'-'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// print a negative sign
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// convert the number to positive
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;started&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX_DIGITS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow_10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pow_10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;started&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// don't print trailing zeroes
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;started&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;putc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;digit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now you’ll see why we need those three functions we implemented before. Now lets implement this in assembly:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;%define&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX_DIGITS&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_print_answer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;enter&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;              &lt;span class=&quot;c&quot;&gt;; we'll use 1 byte for &quot;started&quot; variable in C&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edi&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esi&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;; our &quot;a&quot; argument&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;              &lt;span class=&quot;c&quot;&gt;; if the number is not negative, skip this if-statement&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_print_answer_negate_end&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; call putc for '-'&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2d&lt;/span&gt;               &lt;span class=&quot;c&quot;&gt;; '-' character&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_putc&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;neg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;                 &lt;span class=&quot;c&quot;&gt;; convert a to positive&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_print_answer_negate_end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;; started = 0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX_DIGITS&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;; our i variable&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_print_answer_loop_start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;je&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_print_answer_loop_end&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; call pow_10 for ecx. We'll be trying to get ebx to be out &quot;digit&quot; variable in C.&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; For now we'll get edx = pow_10(i-1) and ebx = pow_10(i)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;dec&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;             &lt;span class=&quot;c&quot;&gt;; i-1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;; arg1 for _pow_10&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_pow_10&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;; edx = pow_10(i-1)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;             &lt;span class=&quot;c&quot;&gt;; restore ecx to i&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; end pow_10 call&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;; digit = ebx = pow_10(i-1)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;imul&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;; digit = ebx = pow_10(i)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; call _mod for (a % pow_10(i)), which is (eax mod ebx)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;; arg2, ebx = digit = pow_10(i)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;; arg1, eax = a&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_mod&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;; digit = ebx = a % pow_10(i+1), almost there&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; end mod call&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; divide ebx (&quot;digit&quot; var) by pow_10(i) (edx).  We'll need to save a few registers&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; since idiv requires both edx and eax for the dividend. Since edx is our divisor,&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; we'll need to move it to some other register&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esi&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;idiv&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esi&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;; eax holds the result (the digit)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;; ebx = (a % pow_10(i)) / pow_10(i-1), the &quot;digit&quot; variable in C&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esi&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; end division&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;                        &lt;span class=&quot;c&quot;&gt;; if digit == 0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jne&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_print_answer_trailing_zeroes_check_end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;               &lt;span class=&quot;c&quot;&gt;; if started == 0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jne&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_print_answer_trailing_zeroes_check_end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_print_answer_loop_continue&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;; continue&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_print_answer_trailing_zeroes_check_end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;; started = 1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x30&lt;/span&gt;           &lt;span class=&quot;c&quot;&gt;; digit + '0'&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; call putc&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_putc&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; end call putc&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_print_answer_loop_continue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_print_answer_loop_start&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_print_answer_loop_end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esi&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edi&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;leave&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;That was a tough one! Hopefully tracing through the comments help. If now all you’re thinking is “Man I sure wish I could have used &lt;code class=&quot;highlighter-rouge&quot;&gt;printf(&quot;%d&quot;)&lt;/code&gt;, then you will enjoy the end of this article when we replace this function with just that!&lt;/p&gt;

&lt;p&gt;Now that we have all the functions necessary, we can implement the main logic in &lt;code class=&quot;highlighter-rouge&quot;&gt;_start&lt;/code&gt; and we’ll be done!&lt;/p&gt;

&lt;h2 id=&quot;evaluating-reverse-polish-notation&quot;&gt;Evaluating Reverse Polish notation&lt;/h2&gt;

&lt;p&gt;As we’ve said before, Reverse Polish notation is evaluated using a stack. When a number is read it is pushed onto the stack, and when an operator is read it is applied to the two operands at the top of the stack.&lt;/p&gt;

&lt;p&gt;For example, if we wish to evaluate &lt;code class=&quot;highlighter-rouge&quot;&gt;84/3+6*&lt;/code&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, that process would look like:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Step&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Character checked&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Stack before&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Stack after&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[8]&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[8]&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[8, 4]&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[8, 4]&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[2]&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[2]&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[2, 3]&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[2, 3]&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[5]&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;6&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[5]&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[5, 6]&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[5, 6]&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[30]&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If the input is a valid postfix expression, at the end there will only be one element on the stack, which will be the answer the expression evaluates to. So in this case, the expression evaluates to &lt;code class=&quot;highlighter-rouge&quot;&gt;30&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What we need to implement in assembly is something like the following C code:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;// 256 is probably plenty big for our stack
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input_length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input_length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'0'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'9'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// if the character is a digit
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// convert the character digit to an integer and push that
&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'+'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'-'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'*'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'/'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Invalid input&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Invalid input&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;print_answer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Since we now have all of the functions necessary to implement this, lets get started.&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; you do not get the arguments of _start the same way you do in other functions.&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; instead, esp points directly to argc (the number of arguments), and esp+4 points&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; to argv. Therefore, esp+4 points to the name of your program, esp+8 points to&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; the first argument, etc&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;; esi = &quot;input&quot; = argv[0]&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; call _strlen to find the length of the input&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esi&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_strlen&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;             &lt;span class=&quot;c&quot;&gt;; ebx = input_length&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; end _strlen call&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;               &lt;span class=&quot;c&quot;&gt;; ecx = &quot;i&quot;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_main_loop_start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;             &lt;span class=&quot;c&quot;&gt;; if (i &amp;gt;= input_length)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_main_loop_end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;esi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;; load only a byte from memory into the lower byte of&lt;/span&gt;
                             &lt;span class=&quot;c&quot;&gt;; edx. We set the rest of edx to zero.&lt;/span&gt;
                             &lt;span class=&quot;c&quot;&gt;; edx = c variable = input[i]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'0'&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_check_operator&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'9'&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_print_error&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'0'&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;             &lt;span class=&quot;c&quot;&gt;; eax = c variable - '0' (the numeric digit, not char)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_push_eax_and_continue&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_check_operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; call _pop twice to pop b into edi and a into eax&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_pop&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;             &lt;span class=&quot;c&quot;&gt;; edi = b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_pop&lt;/span&gt;                &lt;span class=&quot;c&quot;&gt;; eax = a&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; end call _pop&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'+'&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jne&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_subtract&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edi&lt;/span&gt;                 &lt;span class=&quot;c&quot;&gt;; eax = a+b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_push_eax_and_continue&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_subtract&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'-'&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jne&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_multiply&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edi&lt;/span&gt;                 &lt;span class=&quot;c&quot;&gt;; eax = a-b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_push_eax_and_continue&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_multiply&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'*'&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jne&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_divide&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;imul&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edi&lt;/span&gt;                &lt;span class=&quot;c&quot;&gt;; eax = a*b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_push_eax_and_continue&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_divide&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'/'&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jne&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_print_error&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;                     &lt;span class=&quot;c&quot;&gt;; save edx since we'll need to set it to 0 for idiv&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;idiv&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edi&lt;/span&gt;                     &lt;span class=&quot;c&quot;&gt;; eax = a/b&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; now we push eax and continue&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_push_eax_and_continue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; call _push&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;; arg1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_push&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; end call _push&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;inc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_main_loop_start&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_main_loop_end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack_size&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;; if (stack_size != 1) print error&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jne&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_print_error&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[stack]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_print_answer&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; print a final newline&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xA&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_putc&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; exit successfully&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x01&lt;/span&gt;           &lt;span class=&quot;c&quot;&gt;; 0x01 = exit()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;              &lt;span class=&quot;c&quot;&gt;; 0 = no errors&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x80&lt;/span&gt;                &lt;span class=&quot;c&quot;&gt;; execution will end here&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_print_error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error_msg&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_print_msg&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x01&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You’ll also need to add a &lt;code class=&quot;highlighter-rouge&quot;&gt;error_msg&lt;/code&gt; string to your &lt;code class=&quot;highlighter-rouge&quot;&gt;.rodata&lt;/code&gt; section, something like:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rodata&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; Declare some bytes at a symbol called error_msg. NASM's db pseudo-instruction&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; allows either a single byte value, a constant string, or a combination of the two&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; as seen here. 0xA = new line, and 0x0 = string-terminating null&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;error_msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Invalid input&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And we’re done! Time to impress all your friends, if you have any. Hopefully at this point you have a new appreciation for higher-level languages, especially when you realize that many older programs were written entirely or almost entirely in assembly, such as the original RollerCoaster Tycoon!&lt;/p&gt;

&lt;p&gt;The complete code can be found &lt;a href=&quot;https://gist.github.com/dere/9dff75a67710207e16cd6a8531393ccf&quot;&gt;here&lt;/a&gt;. Thanks for reading! Continue on for some extra credit, if you dare.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next steps&lt;/h2&gt;

&lt;p&gt;Here are some features you can add for additional practice:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Throw an error if the user does not supply 1 argument to the program instead of just segfaulting&lt;/li&gt;
  &lt;li&gt;Add support for optional spaces between operands and operators in the input&lt;/li&gt;
  &lt;li&gt;Add support for multi-digit operands&lt;/li&gt;
  &lt;li&gt;Allow negative numbers in the input&lt;/li&gt;
  &lt;li&gt;Replace &lt;code class=&quot;highlighter-rouge&quot;&gt;_strlen&lt;/code&gt; with the one in &lt;a href=&quot;https://en.wikipedia.org/wiki/X86_assembly_language#.22Hello_world.21.22_program_for_Linux_in_NASM_style_assembly_using_the_C_standard_library&quot;&gt;the C standard library&lt;/a&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;_print_answer&lt;/code&gt; with a call to &lt;code class=&quot;highlighter-rouge&quot;&gt;printf&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;additional-reading&quot;&gt;Additional reading&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cs.virginia.edu/~evans/cs216/guides/x86.html&quot;&gt;University of Virginia’s Guide to x86 Assembly&lt;/a&gt; – Goes more into depth on many of the topics covered here, including more information on each of the most common x86 instructions. A great reference for the most common x86 instructions as well.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.swansontec.com/sregisters.html&quot;&gt;The Art of Picking Intel Registers&lt;/a&gt; – While most of the x86 registers are general-purpose, many of the registers have a historical meaning. Following those conventions can improve code readability, and as an interesting side benefit, will even slightly optimize the size of your binaries.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.posix.nl/linuxassembly/nasmdochtml/nasmdoca.html&quot;&gt;NASM: Intel x86 Instruction Reference&lt;/a&gt; - a full reference to all the obscure x86 instructions.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;6384/+*&lt;/code&gt; is another way of writing the same expression.&amp;nbsp;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 13 Feb 2017 00:00:00 -0500</pubDate>
        <link>http://localhost:4000/2017/02/13/beginners-assembly-part2/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/13/beginners-assembly-part2/</guid>
      </item>
    
      <item>
        <title>A Beginner's Guide to x86 Assembly, Part 1 of 2</title>
        <description>&lt;p&gt;Writing bare assembly is rarely necessary these days, but I definitely recommend it for anyone interested in programming. Not only does it offer a different perspective compared to higher-level languages, but it may prove to be useful when debugging code in other languages.&lt;/p&gt;

&lt;p&gt;In this two-part series we will be implementing a &lt;a href=&quot;https://en.wikipedia.org/wiki/Reverse_Polish_notation&quot;&gt;Reverse Polish notation (RPN)&lt;/a&gt; calculator in bare x86 assembly from the ground up. When we’re done we’ll be able to use it like this:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;./calc &lt;span class=&quot;s2&quot;&gt;&quot;32+6*&quot;&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# &quot;(3+2)*6&quot; in infix notation&lt;/span&gt;
30
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The complete code from the end of Part 1 can be found &lt;a href=&quot;https://gist.github.com/dere/79dca38ccc2a5e263d0635f1b7737ec9&quot;&gt;here&lt;/a&gt;. Additionally, if you feel like taking a peek, the complete code from the end of this series can be found &lt;a href=&quot;https://gist.github.com/dere/9dff75a67710207e16cd6a8531393ccf&quot;&gt;here&lt;/a&gt;. It is heavily commented and these two may serve as a sufficient learning resource for those of you with some knowledge of assembly already.&lt;/p&gt;

&lt;p&gt;In Part 1 we will begin with a basic “Hello world!” program to ensure your setup is working properly. We will progress to explaining system calls, call stack, stack frames, and the x86 calling convention. We will then finish by writing some basic functions in x86 assembly for practice. In Part 2 we we will begin our RPN calculator from scratch.&lt;/p&gt;

&lt;p&gt;This article series is aimed at people who have some experience programming in C and have some basic knowledge of computer architecture (such as what a CPU register is). Since we will be using Linux you will also need to know how to use the Linux command line.&lt;/p&gt;

&lt;h2 id=&quot;setup&quot;&gt;Setup&lt;/h2&gt;

&lt;p&gt;As stated before, we will be using Linux (either 64-bit or 32-bit). The code in this article series will not work on Windows or Mac OS X.&lt;/p&gt;

&lt;p&gt;You simply need the GNU linker &lt;code class=&quot;highlighter-rouge&quot;&gt;ld&lt;/code&gt; from &lt;code class=&quot;highlighter-rouge&quot;&gt;binutils&lt;/code&gt;, which is pre-installed on most distros, and the NASM assembler. On Ubuntu and Debian you can install both with:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;sudo apt-get install binutils nasm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;I would also recommend you keep an &lt;a href=&quot;http://www.asciitable.com/&quot;&gt;ASCII table&lt;/a&gt; handy.&lt;/p&gt;

&lt;h2 id=&quot;hello-world&quot;&gt;Hello world&lt;/h2&gt;

&lt;p&gt;To ensure your setup is ready to begin, save the following code into a file called &lt;code class=&quot;highlighter-rouge&quot;&gt;calc.asm&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;; Allow the linker to find the _start symbol. The linker will begin program execution&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; there.&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_start&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;; Start the .rodata section of the executable, which stores constants (read only data)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;; It doesn't matter which order your sections are in, I just like putting .data first&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rodata&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; Declare some bytes at a symbol called hello_world. NASM's db pseudo-instruction&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; allows either a single byte value, a constant string, or a combination of the two&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; as seen here. 0xA = new line, and 0x0 = string-terminating null&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hello_world&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello world!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;; Start the .text section, which stores program code&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x04&lt;/span&gt;           &lt;span class=&quot;c&quot;&gt;; store the number 4 in the eax register (0x04 = write())&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;; file descriptor (1 = standard output, 2 = standard error)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello_world&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;; pointer to the string we're printing&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;             &lt;span class=&quot;c&quot;&gt;; length of the string&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x80&lt;/span&gt;                &lt;span class=&quot;c&quot;&gt;; send the interrupt signal 0x80 which the OS interprets as&lt;/span&gt;
                            &lt;span class=&quot;c&quot;&gt;;   a syscall&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x01&lt;/span&gt;           &lt;span class=&quot;c&quot;&gt;; 0x01 = exit()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;              &lt;span class=&quot;c&quot;&gt;; 0 = no errors&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The comments should explain the general strucure, but you are probably a bit confused on how it works. If you are confused about the instructions or the registers used, you can reference &lt;a href=&quot;http://www.cs.virginia.edu/~evans/cs216/guides/x86.html&quot;&gt;University of Virginia’s Guide to x86 Assembly&lt;/a&gt; for a list of registers and common instructions. Once we discuss system calls this should hopefully make even more sense.&lt;/p&gt;

&lt;p&gt;To assemble the assembly file into an object file, then to link the object file into an executable, run:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;nasm -f elf_i386 calc.asm -o calc
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;ld -m elf_i386 calc.o -o calc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;When run you should see:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;./calc
Hello world!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;makefile&quot;&gt;Makefile&lt;/h3&gt;

&lt;p&gt;This part is optional, but to easily assemble and link in the future, we can create use Make. Save the following into a file called &lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt; in the same directory as your &lt;code class=&quot;highlighter-rouge&quot;&gt;calc.asm&lt;/code&gt; file:&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;CFLAGS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; -f elf32
&lt;span class=&quot;nv&quot;&gt;LFLAGS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; -m elf_i386

&lt;span class=&quot;nl&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calc&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;calc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calc.o&lt;/span&gt;
	ld &lt;span class=&quot;nv&quot;&gt;$(LFLAGS)&lt;/span&gt; calc.o -o calc

&lt;span class=&quot;nl&quot;&gt;calc.o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calc.asm&lt;/span&gt;
	nasm &lt;span class=&quot;nv&quot;&gt;$(CFLAGS)&lt;/span&gt; calc.asm -o calc.o

&lt;span class=&quot;nl&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
	rm -f calc.o calc
        
&lt;span class=&quot;nl&quot;&gt;.INTERMEDIATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;calc.o&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then to assemble and link, instead of following the above instructions, you can simply run &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;system-calls&quot;&gt;System calls&lt;/h2&gt;

&lt;p&gt;System calls are used to request the operating system to perform an action for us. In this article, we will only be using two system calls&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;write()&lt;/code&gt;, which writes a string to a file or stream (in our case, to standard out and standard error), and &lt;code class=&quot;highlighter-rouge&quot;&gt;exit()&lt;/code&gt;, to exit the program:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;syscall 0x01: exit(int error_code)
  error_code - use 0 to exit without errors, and use anything else (such as 1) for errors
syscall 0x04: write(int fd, char *string, int length)
  fd - use 1 for standard output, 2 for standard error output
  string - a pointer to the first character of the string
  length - the length of the string in bytes
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;System calls are set up by storing the system call number in register &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt;, followed by its arguments in &lt;code class=&quot;highlighter-rouge&quot;&gt;ebx&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ecx&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;edx&lt;/code&gt; in that order. You may notice &lt;code class=&quot;highlighter-rouge&quot;&gt;exit()&lt;/code&gt; only has one argument – in that case, it doesn’t matter what value &lt;code class=&quot;highlighter-rouge&quot;&gt;ecx&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;edx&lt;/code&gt; have.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;eax&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;ebx&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;ecx&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;edx&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;syscall number&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;arg1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;arg2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;arg3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;the-call-stack&quot;&gt;The call stack&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-12-beginners-assembly/callstack.png&quot; alt=&quot;The call stack&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The call stack is a data structure that stores information about each function call. Each function call has its own section in the stack called a “frame,” which stores some information about the current function call, such as the local variables of that function and the return address (where the program should jump to once the function is done executing).&lt;/p&gt;

&lt;p&gt;One confusing thing that I will note immediately is that the stack grows &lt;em&gt;downwards&lt;/em&gt; in memory. When you add something to the top of the stack, it will be inserted at a memory address lower than the previous thing in the stack. In other words, as the stack grows, the memory address of the top of the stack decreases. To prevent confusion, I will not mention that fact unless it is absolutely necessary because we are working with memory addresses of items on the stack.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt; instruction will insert some onto the top of the stack, and &lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt; will remove data from the top of the stack. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;push eax&lt;/code&gt; will allocate more space on the top of the stack and move the value in &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt; to that space, and &lt;code class=&quot;highlighter-rouge&quot;&gt;pop eax&lt;/code&gt; will move whatever data is at the top of the stack into &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt; and unallocate that space from the stack.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;esp&lt;/code&gt; register’s purpose is to point to the top of the stack. Any data above &lt;code class=&quot;highlighter-rouge&quot;&gt;esp&lt;/code&gt; is considered not on the stack, it is garbage data. Performing a &lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt; instruction to add data to the top of the stack (or a &lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt; to remove data) will move &lt;code class=&quot;highlighter-rouge&quot;&gt;esp&lt;/code&gt;. You can also manipulate &lt;code class=&quot;highlighter-rouge&quot;&gt;esp&lt;/code&gt; directly if you know what you’re doing.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;ebp&lt;/code&gt; register is similar except it always points somewhere in the middle of the current stack frame, directly before the local variables of the current function (we’ll talk more about this later). However, calling another function does not move &lt;code class=&quot;highlighter-rouge&quot;&gt;ebp&lt;/code&gt; automatically, we must do that manually each time.&lt;/p&gt;

&lt;h2 id=&quot;the-x86-calling-convention&quot;&gt;The x86 calling convention&lt;/h2&gt;

&lt;p&gt;x86 has no built-in notion of a function like higher-level languages do. The x86 &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; instruction is essentially just a &lt;code class=&quot;highlighter-rouge&quot;&gt;jmp&lt;/code&gt; (a &lt;code class=&quot;highlighter-rouge&quot;&gt;goto&lt;/code&gt;) to another place in memory. In order to use subroutines like we use functions in other languages (which can take arguments and return data back), we must follow a calling convention&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;. That will also ensure that a subroutine’s registers will not be messed up when calling another function.&lt;/p&gt;

&lt;h3 id=&quot;caller-rules&quot;&gt;Caller rules&lt;/h3&gt;

&lt;p&gt;Before calling the function, the caller must:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Save the &lt;em&gt;caller-saved registers&lt;/em&gt; by pushing them onto the stack. Some registers are able to be modified by the called function, and to ensure you do not lose the data in those registers, the caller must save them in memory before the call by pushing them onto the stack. These registers are &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ecx&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;edx&lt;/code&gt;. If you were not using some or all of those registers then you do not need to save them.&lt;/li&gt;
  &lt;li&gt;Push the function’s arguments onto the stack in reverse order (pushing the last argument first and the first argument last). This order ensures that the called function will have its arguments in correct order when popping them from the stack.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt; the subroutine.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The function will store its result in &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt; if applicable. Immediately after the &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;, the caller must:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Remove the function’s arguments from the stack. This is typically done by simply adding the number of bytes to &lt;code class=&quot;highlighter-rouge&quot;&gt;esp&lt;/code&gt;. Don’t forget that the stack grows downward, so to remove from the stack you must add.&lt;/li&gt;
  &lt;li&gt;Restore the caller-saved registers by popping them from the stack in reverse order. No other registers will have been modified by the called function.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The following example sums up the above caller rules. In this example, assume I have a function called &lt;code class=&quot;highlighter-rouge&quot;&gt;_subtract&lt;/code&gt; which takes two integer (4-byte) arguments and returns the first argument minus the second argument. In my subroutine called &lt;code class=&quot;highlighter-rouge&quot;&gt;_mysubroutine&lt;/code&gt;, I call &lt;code class=&quot;highlighter-rouge&quot;&gt;_subtract&lt;/code&gt; with the arguments &lt;code class=&quot;highlighter-rouge&quot;&gt;10&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_mysubroutine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; ...&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; some code here&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; ...&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;       &lt;span class=&quot;c&quot;&gt;; save the caller-saved registers (I choose to not save eax)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;; rule 2, push args in reverse order&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_subtract&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;; eax is now equal to 10-2=8&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;; remove 8 bytes from the stack (2 arguments, 4 bytes each)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;; restore caller-saved registers&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; ...&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; some code here where I use my amazingly-useful value in eax&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;callee-rules&quot;&gt;Callee rules&lt;/h3&gt;

&lt;p&gt;In order to be called, a subroutine must:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Save the previous frame’s base pointer &lt;code class=&quot;highlighter-rouge&quot;&gt;ebp&lt;/code&gt; by pushing it onto the stack.&lt;/li&gt;
  &lt;li&gt;Adjust &lt;code class=&quot;highlighter-rouge&quot;&gt;ebp&lt;/code&gt;, which currently points to the previous frame, to point to the current frame (the current value of &lt;code class=&quot;highlighter-rouge&quot;&gt;esp&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Allocate more space on the stack for local variables, if necessary, by moving the stack pointer &lt;code class=&quot;highlighter-rouge&quot;&gt;esp&lt;/code&gt;. Since the stack growns downwards, that means you should subtract from &lt;code class=&quot;highlighter-rouge&quot;&gt;esp&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Save the &lt;em&gt;callee-saved registers&lt;/em&gt; by pushing them onto the stack. These are: &lt;code class=&quot;highlighter-rouge&quot;&gt;ebx&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;edi&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;esi&lt;/code&gt;. You do not have to save any registers you are not planning on modifying.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The call stack after step 1:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-12-beginners-assembly/callee-rules-step1.png&quot; alt=&quot;The stack after step 1&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The call stack after step 2:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-12-beginners-assembly/callee-rules-step2.png&quot; alt=&quot;The stack after step 2&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The call stack once you’re done with step 4:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2017-02-12-beginners-assembly/callee-rules-step4.png&quot; alt=&quot;The stack after step 4&quot; class=&quot;center-image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You may notice a return address in each stack frame in those diagrams. Those are inserted into the stack automatically by &lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;. A &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt; instruction pops the address on the top of the stack and jumps to that location. We don’t have to use it for anything, I only include it to show why the function’s local variables are 4 bytes above &lt;code class=&quot;highlighter-rouge&quot;&gt;ebp&lt;/code&gt; but the function’s arguments are 8 bytes below &lt;code class=&quot;highlighter-rouge&quot;&gt;ebp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You may also notice in the last diagram above that the local variables of a function always begin 4 bytes above &lt;code class=&quot;highlighter-rouge&quot;&gt;ebp&lt;/code&gt; at the address &lt;code class=&quot;highlighter-rouge&quot;&gt;ebp-4&lt;/code&gt; (you subtract because addresses go down as you move up the stack) and the arguments of a function always begin 8 bytes below &lt;code class=&quot;highlighter-rouge&quot;&gt;ebp&lt;/code&gt; at the address &lt;code class=&quot;highlighter-rouge&quot;&gt;ebp+8&lt;/code&gt; (you add to move down the stack). If you follow the callee rules, this will always be the case for any function.&lt;/p&gt;

&lt;p&gt;Once your function is done executing and you wish to return, you should first set &lt;code class=&quot;highlighter-rouge&quot;&gt;eax&lt;/code&gt; to the return value of your function if necessary. Additionally you must:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Restore the callee-saved registers by popping them from the stack in reverse order.&lt;/li&gt;
  &lt;li&gt;Deallocate the space on the stack you allocated in step 3 above for local variables, if applicable. This can be done simply by setting &lt;code class=&quot;highlighter-rouge&quot;&gt;esp&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;ebp&lt;/code&gt;. This is safe to do even if you didn’t allocate any space in the first place.&lt;/li&gt;
  &lt;li&gt;Restore the previous frame’s base pointer &lt;code class=&quot;highlighter-rouge&quot;&gt;ebp&lt;/code&gt; by popping it from the stack.&lt;/li&gt;
  &lt;li&gt;Return with &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Now we’ll implement our &lt;code class=&quot;highlighter-rouge&quot;&gt;_subtract&lt;/code&gt; function from our example above:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_subtract&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;; save the previous frame's base pointer&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;; adjust ebp&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; Here I'd allocate space on the stack for local variables, but I don't need any&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; Here I'd save the callee-saved registers, but I won't be modifying any&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; My function begins here&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;; copy the function's first argument into eax. The brackets mean&lt;/span&gt;
                        &lt;span class=&quot;c&quot;&gt;; to access the data in memory at the location ebp+8&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;; subtract the second argument at ebp+12 from the first argument&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; My function ends here. eax is equal to my function's return value&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; Here I'd restore the callee-saved registers, but I didn't save any&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; Here I'd deallocate variables, but I didn't allocate any&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;             &lt;span class=&quot;c&quot;&gt;; restore the previous frame's base pointer&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;enter-and-leave&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;enter&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;leave&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;You may notice in the example above that a function will always start the same: &lt;code class=&quot;highlighter-rouge&quot;&gt;push ebp&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mov ebp, esp&lt;/code&gt;, and allocating space for local variables. x86 has a handy instruction to accomplish this for us: &lt;code class=&quot;highlighter-rouge&quot;&gt;enter a b&lt;/code&gt;, where &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; is the number of bytes you’d like to allocate for local variables, and &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; is the “nesting level” which we will always leave at &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;. Additionally, a function always ends with &lt;code class=&quot;highlighter-rouge&quot;&gt;pop ebp&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;mov esp, ebp&lt;/code&gt;&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;. This can also be replaced with a single instruction: &lt;code class=&quot;highlighter-rouge&quot;&gt;leave&lt;/code&gt;. Using these, our example above becomes:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_subtract&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;enter&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;; save the previous frame's base pointer and adjust ebp&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; Here I'd save the callee-saved registers, but I won't be modifying any&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; My function begins here&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;; copy the function's first argument into eax. The brackets mean&lt;/span&gt;
                        &lt;span class=&quot;c&quot;&gt;; to access the data in memory at the location ebp+8&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;; subtract the second argument at ebp+12 from the first argument&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; My function ends here. eax is equal to my function's return value&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; Here I'd restore the callee-saved registers, but I didn't save any&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;leave&lt;/span&gt;               &lt;span class=&quot;c&quot;&gt;; deallocate and restore the previous frame's base pointer&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;writing-some-basic-functions&quot;&gt;Writing some basic functions&lt;/h2&gt;

&lt;p&gt;Now that we understand the calling convention, we can begin writing some subroutines. It would be pretty handy to generalizing the code that prints the “Hello world!” to print any string we’d like, a &lt;code class=&quot;highlighter-rouge&quot;&gt;_print_msg&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;For that function we will need a &lt;code class=&quot;highlighter-rouge&quot;&gt;_strlen&lt;/code&gt; function to count the length of the string. That function might look like this in C:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;// loop start
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;// loop end
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In other words, starting at the beginning of the string, we add &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; to the return value for every character we see that is not the string-terminating null character &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;. Once that null character is seen, we return. In assembly it is also pretty simple using our example &lt;code class=&quot;highlighter-rouge&quot;&gt;_subtract&lt;/code&gt; function above as a base:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_strlen&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;enter&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;; save the previous frame's base pointer and adjust ebp&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; Here I'd save the callee-saved registers, but I won't be modifying any&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; My function begins here&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;; length = 0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;; copy the function's first argument (pointer to the first &lt;/span&gt;
                        &lt;span class=&quot;c&quot;&gt;; character of the string) into ecx (which is caller-saved, so &lt;/span&gt;
                        &lt;span class=&quot;c&quot;&gt;; no need to save it)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_strlen_loop_start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;c&quot;&gt;; this is a label we can jump to&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[ecx],&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;; dereference that pointer and compare it to null. By default,&lt;/span&gt;
                        &lt;span class=&quot;c&quot;&gt;; many times a memory access will default to reading 32 bits&lt;/span&gt;
                        &lt;span class=&quot;c&quot;&gt;; (4 bytes) from memory. Other times it will always be&lt;/span&gt;
                        &lt;span class=&quot;c&quot;&gt;; required. Here we use a Size Directive to only read one byte,&lt;/span&gt;
			&lt;span class=&quot;c&quot;&gt;; since a character is only one byte&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;je&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_strlen_loop_end&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;; jump out of the loop if it is equal to null&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;inc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;             &lt;span class=&quot;c&quot;&gt;; now we're in the loop body. add 1 to our return value&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;; increment to the next character in the string&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;jmp&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_strlen_loop_start&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; jump back to the top of the loop&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_strlen_loop_end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; My function ends here. eax is equal to my function's return value&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; Here I'd restore the callee-saved registers, but I didn't save any&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;leave&lt;/span&gt;               &lt;span class=&quot;c&quot;&gt;; deallocate and restore the previous frame's base pointer&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;That wasn’t too bad, right? Writing the code in C beforehand may help you a lot because much of it can be directly converted to assembly. Now we can use this function in our &lt;code class=&quot;highlighter-rouge&quot;&gt;_print_msg&lt;/code&gt; function, which will require everything we’ve learned so far:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_print_msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;enter&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; My function begins here&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x04&lt;/span&gt;       &lt;span class=&quot;c&quot;&gt;; 0x04 = the write() syscall&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;; 0x1 = standard output&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;; the string we want to print is the first arg of this function&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; at this point we wish to set edx to the length of the string. time to call _strlen&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;; save the caller-saved registers (I choose to not save edx)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;       
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dword&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;; push _strlen's argument, the string argument to _print_msg. NASM&lt;/span&gt;
                        &lt;span class=&quot;c&quot;&gt;; complains if you do not put a size directive here, and I'm not&lt;/span&gt;
                        &lt;span class=&quot;c&quot;&gt;; sure why. Anyway, a pointer is a dword (4 bytes, 32 bits)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_strlen&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;; eax is now equal to the length of the string&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;        &lt;span class=&quot;c&quot;&gt;; move the length into edx where we wanted it&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;          &lt;span class=&quot;c&quot;&gt;; remove 4 bytes from the stack (one 4-byte char* argument)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ecx&lt;/span&gt;             &lt;span class=&quot;c&quot;&gt;; restore caller-saved registers&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;pop&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; we're done calling _strlen and setting up the syscall&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x80&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;leave&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And lets see the fruit of our hard work by using that function in our complete “Hello world!” program:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;_start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;enter&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;; save the caller-saved registers (I choose to not save any)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello_world&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;; push the argument to _print_msg&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;call&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_print_msg&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x01&lt;/span&gt;           &lt;span class=&quot;c&quot;&gt;; 0x01 = exit()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;              &lt;span class=&quot;c&quot;&gt;; 0 = no errors&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;That is the end of Part 1. Believe it or not, we have covered all the main x86 topics you will need to write basic x86 programs! In the next article we will apply this knowledge to write our RPN calculator. Now that we have all the introductory material and theory out of the way, Part 2 will be focusing entirely on the code. The functions we write will be much longer and will even have to use some local variables as well.&lt;/p&gt;

&lt;p&gt;If you’d like to see the complete program up to this point click &lt;a href=&quot;https://gist.github.com/dere/79dca38ccc2a5e263d0635f1b7737ec9&quot;&gt;here&lt;/a&gt;. Thanks for reading! I’ll see you in &lt;a href=&quot;/2017-02-13/beginners-assembly-part2/&quot;&gt;Part 2&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;additional-reading&quot;&gt;Additional reading&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cs.virginia.edu/~evans/cs216/guides/x86.html&quot;&gt;University of Virginia’s Guide to x86 Assembly&lt;/a&gt; – Goes more into depth on many of the topics covered here, including more information on each of the most common x86 instructions. A great reference for the most common x86 instructions as well.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.swansontec.com/sregisters.html&quot;&gt;The Art of Picking Intel Registers&lt;/a&gt; – While most of the x86 registers are general-purpose, many of the registers have a historical meaning. Following those conventions can improve code readability, and as an interesting side benefit, will even slightly optimize the size of your binaries.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.posix.nl/linuxassembly/nasmdochtml/nasmdoca.html&quot;&gt;NASM: Intel x86 Instruction Reference&lt;/a&gt; - a full reference to all the obscure x86 instructions.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;If interested you may find a reference for more Linux system calls &lt;a href=&quot;http://syscalls.kernelgrok.com/&quot;&gt;here&lt;/a&gt;.&amp;nbsp;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;There are multiple calling conventions, but we will be using CDECL, the most popular calling convention for x86 in use by C compilers and assembly programmers.&amp;nbsp;&lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;While &lt;code class=&quot;highlighter-rouge&quot;&gt;mov esp, ebp&lt;/code&gt; is only necessary if you’ve allocated memory on the stack for local variables, as mentioned in point 2 above it is safe to do if you didn’t, so &lt;code class=&quot;highlighter-rouge&quot;&gt;leave&lt;/code&gt; can be used even if you haven’t allocated anything.&amp;nbsp;&lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 12 Feb 2017 00:00:00 -0500</pubDate>
        <link>http://localhost:4000/2017/02/12/beginners-assembly-part1/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/12/beginners-assembly-part1/</guid>
      </item>
    
  </channel>
</rss>
